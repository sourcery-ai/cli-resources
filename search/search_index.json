{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Sourcery CLI Resources","text":"<p>Code examples &amp; design patterns for Python CLI applications.</p>"},{"location":"#libraries-used","title":"Libraries Used","text":"<ul> <li>typer</li> <li>Pydantic</li> <li>sqlite-utils</li> <li>Rich</li> </ul>"},{"location":"bool-option/","title":"Bool option","text":"","tags":["option"]},{"location":"bool-option/#overview","title":"Overview","text":"<p>Typer creates per default 2 names for each bool option:</p> <ul> <li>one for the <code>True</code> value</li> <li>one for the <code>False</code> value</li> </ul> <p>You can customize this by providing explicit option names.</p>","tags":["option"]},{"location":"bool-option/#default-bool-option-with-names-for-true-and-false","title":"Default <code>bool</code> Option with Names for <code>True</code> and <code>False</code>","text":"<p>A bool option:</p> <p>This creates 2 options:</p>","tags":["option"]},{"location":"bool-option/#bool-option-with-a-name-only-for-true","title":"<code>bool</code> Option with a Name Only for <code>True</code>","text":"<p>For some <code>bool</code> options, it doesn't make sense to provide a separate name for the <code>False</code> value.</p> <p>This snippet defines a <code>--version</code> option without creating a respective <code>--no-version</code>:</p> <pre><code>@app.command()\ndef some_cmd(\nversion: bool = typer.Option(False, \"--version\", help=\"Print the current version.\"),\n) -&gt; None:\n</code></pre>","tags":["option"]},{"location":"bool-option/#bool-option-with-a-custom-name-for-false","title":"<code>bool</code> Option with a Custom Name for <code>False</code>","text":"<pre><code>@app.command()\ndef some_cmd(\naccept: bool = typer.Option(True, \"--accept/--reject\", help=\"Accept or reject. Default: accept\"),\n) -&gt; None:\n</code></pre>","tags":["option"]},{"location":"bool-option/#bool-options-with-3-possible-values","title":"<code>bool</code> Options with 3 Possible Values","text":"<p>This is possible but not recommended.</p> <p>You can also define an option with the type <code>Optional[bool]</code>. These options have 3 possible values:</p> <ul> <li><code>None</code></li> <li><code>True</code></li> <li><code>False</code></li> </ul> <pre><code>@app.command()\ndef trio(\nsize_option: bool = typer.Option(\nNone, \"--small/--big\", help=\"The size of something. Default: medium\"\n),\n) -&gt; None:\nif size_option is None:\nsize = \"medium\"\nelif size_option:\nsize = \"small\"\nelse:\nsize = \"big\"\nConsole().print(size)\n</code></pre> <p>Note that this behavior might be surprising / confusing.</p>","tags":["option"]},{"location":"bool-option/#more-info","title":"More Info","text":"<ul> <li>Typer Docs / CLI Option Name</li> <li>Typer Docs / Boolean CLI Options</li> <li>CLIG / Arguments and Flags</li> </ul>","tags":["option"]},{"location":"command-alias/","title":"Command alias","text":"","tags":["command","naming"]},{"location":"command-alias/#overview","title":"Overview","text":"<p>Typer doesn't support multiple aliases for the same command.</p> <p>You can define an alias in Python by:</p> <ul> <li>Calling one command function from the other.</li> <li>Calling the same private function from both commands.</li> </ul>","tags":["command","naming"]},{"location":"command-alias/#two-commands-calling-the-same-function","title":"Two Commands Calling the Same Function","text":"<p>Create 2 commands <code>pycon</code> and <code>display-pycon</code> executing the same function:</p> <pre><code>@app.command()\ndef display_pycon():\n_print_pycon()\n@app.command()\ndef pycon():\n_print_pycon()\ndef _print_pycon():\nConsole().print(\"PyCon!\")\n</code></pre> <p>If the aliased command also has options, consider using the re-use options pattern.</p>","tags":["command","naming"]},{"location":"command-alias/#clig-recommendation-on-command-aliases","title":"CLIG Recommendation on Command Aliases","text":"<p>Don\u2019t allow arbitrary abbreviations of subcommands. For example, say your command has an install subcommand. When you added it, you wanted to save users some typing, so you allowed them to type any non-ambiguous prefix, like mycmd ins, or even just mycmd i, and have it be an alias for mycmd install. Now you\u2019re stuck: you can\u2019t add any more commands beginning with i, because there are scripts out there that assume i means install.</p> <p>There\u2019s nothing wrong with aliases\u2014saving on typing is good\u2014but they should be explicit and remain stable.</p> <p>CLIG Guidelines / Future-proofing</p>","tags":["command","naming"]},{"location":"command-alias/#more-info","title":"More Info","text":"<ul> <li>CLIG Guidelines / Naming</li> <li>CLIG Guidelines / Subcommands</li> <li>CLIG Guidelines / Future-proofing</li> </ul>","tags":["command","naming"]},{"location":"command-custom-name/","title":"Command custom name","text":"","tags":["command","naming"]},{"location":"command-custom-name/#overview","title":"Overview","text":"<p>By default, Typer creates a command with the same name as the function.</p> <ul> <li>If the function name contains an <code>_</code> =&gt; It wil be replaced with <code>-</code>.</li> <li>You can define a custom command name in the 1st argument of the <code>@app.command()</code> decorator.</li> </ul>","tags":["command","naming"]},{"location":"command-custom-name/#custom-command-name","title":"Custom Command Name","text":"<p>Define a command named <code>list</code> using the function <code>list_items</code>.</p> <pre><code>@app.command(\"list\")\ndef list_items():\n</code></pre> <p>This pattern is useful if your command name is the name of a Python built-in function (like <code>list</code>) or a Python standard library module (like <code>os</code>).</p>","tags":["command","naming"]},{"location":"command-custom-name/#more-info","title":"More Info","text":"<ul> <li>Typer / Custom Command Name</li> <li>CLIG Guidelines / Naming</li> </ul>","tags":["command","naming"]},{"location":"db-path-config/","title":"Configure the Path of a SQLite Database","text":"","tags":["configuration"]},{"location":"db-path-config/#overview","title":"Overview","text":"<p>We want to use different databases in the different environments:</p> <ul> <li>development</li> <li>tests</li> <li>production / live</li> </ul> <p>We use <code>pydantic.Settings</code> and an environment variable to make the path configurable.</p> <ul> <li>For development: set the environment variable.</li> <li>For tests: Use a pytest fixture with <code>tmpdir</code> to define a custom path.</li> </ul>","tags":["configuration"]},{"location":"db-path-config/#config","title":"Config","text":"<p>In a <code>config.py</code>:</p> <pre><code>from pathlib import Path\nfrom pydantic import BaseSettings, Field\nfrom sqlite_utils import Database\nfrom pycon_catalogue.initialize import init_db\nclass Settings(BaseSettings):\ndb_path: Path = Field(\nPath.home() / \"pycon-catalogue.db\", env=\"APP_NAME_DB_PATH\"\n)\ndef db(self) -&gt; Database:\nreturn Database(self.db_path)\nsettings: Settings = Settings()\n</code></pre> <p>Instead of <code>Path.home()</code>, you can also use a more sophisticated default value:</p> <ul> <li><code>typer.get_app_dir()</code></li> <li>platformdirs library</li> </ul>","tags":["configuration"]},{"location":"db-path-config/#setting-a-development-database","title":"Setting a Development Database","text":"<pre><code>export APP_NAME_DB_PATH=$HOME/dev-app-name.db\n</code></pre>","tags":["configuration"]},{"location":"db-path-config/#using-a-temporary-database-for-tests","title":"Using a Temporary Database for Tests","text":"<p>Use a db in <code>tmpdir</code>.</p> <pre><code>from pathlib import Path\nimport pytest\nfrom app_name import config\n@pytest.fixture(autouse=True)\ndef app_db_path(tmpdir):\nconfig.settings.db_path = Path(tmpdir / \"test-app-name.db\")\n</code></pre>","tags":["configuration"]},{"location":"db-path-config/#more-info","title":"More Info","text":"<ul> <li>Pydantic / Settings Management</li> <li><code>tmpdir</code></li> </ul>","tags":["configuration"]},{"location":"help-no-subcommand/","title":"Show Help for Missing Subcommand","text":"","tags":["robustness"]},{"location":"help-no-subcommand/#overview","title":"Overview","text":"<p>If no subcommand has been provided =&gt; Show the help of the command.</p> <p>(instead of raising an error)</p>","tags":["robustness"]},{"location":"help-no-subcommand/#example","title":"Example","text":"<pre><code>@app.callback(invoke_without_command=True)\ndef callback(ctx: typer.Context),\n) -&gt; None:\nif ctx.invoked_subcommand is None:\nConsole().print(ctx.get_help())\n</code></pre>","tags":["robustness"]},{"location":"help-no-subcommand/#more-info","title":"More Info","text":"<ul> <li>Typer Callback docs</li> <li>Typer Context docs</li> </ul>","tags":["robustness"]},{"location":"interactivity/","title":"Interactive Input","text":"","tags":["robustness","option"]},{"location":"interactivity/#overview","title":"Overview","text":"<ul> <li>Prompt for missing values instead of raising an error immediately.</li> <li>Do not prompt if <code>stdin</code> isn't an interactive terminal. \ud83d\udcbb</li> <li>Do not prompt if the <code>--no-input</code> or <code>--no-interactive</code> option has been provided</li> </ul>","tags":["robustness","option"]},{"location":"interactivity/#examples","title":"Examples","text":"","tags":["robustness","option"]},{"location":"interactivity/#basic-example","title":"Basic Example","text":"<p>Prompt for 1 option (<code>--description</code>) if missing.</p> <pre><code>import sys\nimport typer\nfrom rich.prompt import Prompt\n@app.command()\ndef create(\ndescription_option: str = typer.Option(\nNone,\n\"--description\",\nhelp=\"Ca. 1 sentence description.\",\n),\ninteractive_flag: bool = typer.Option(\nTrue,\n\"--interactive/--no-interactive\",\n\"--input/--no-input\",\nhelp=\"Switch whether interactive prompts are shown. Use `--no-input` when you call this command from scripts.\",\n),\n):\ninteractive = sys.stdin.isatty() and interactive_flag\ndescription = description_option or interactive and Prompt.ask(\"Description\")\n</code></pre>","tags":["robustness","option"]},{"location":"interactivity/#more-complex-example","title":"More Complex Example","text":"<ul> <li>If no fields were provided at all via options =&gt; Prompt for all fields.</li> <li>If the object can't be created =&gt; Prompt for the fields that have raised a validation error.</li> </ul> <pre><code>@app.command()\ndef create(\nctx: typer.Context,\nshort_name: str = short_name_option,\nduration_total_seconds: int = duration_total_seconds_option,\nspeaker_name: str = speaker_name_option,\ntitle: str = title_option,\nyoutube_video_id: str = youtube_video_id_option,\ninteractive_flag: bool = INTERACTIVE_OPTION,\nplain: bool = FormatOptions.PLAIN,\nshow_json: bool = FormatOptions.JSON,\n):\n\"\"\"Create a new talk\"\"\"\ninteractive = sys.stdin.isatty() and interactive_flag\nstdout_console = Console()\nstderr_console = Console(stderr=True)\nprovided_further_fields = _get_field_values(ctx, interactive, stderr_console)\ntry:\nresult = talk_crud().create(provided_further_fields)\nexcept ValidationError as e:\nif not interactive or not Talk.all_simple_field_errors(e):\nraise exit_with_error(f\"Can't create a talk. {e}\") from e\nfor error_data in e.errors():\nfield_name = error_data[\"loc\"][0]\nmsg = error_data[\"msg\"]\nstderr_console.print(f\"Validation error. {field_name} {msg}\")\nprovided_further_fields[field_name] = Prompt.ask(field_name)\ntry:\nresult = talk_crud().create(provided_further_fields)\nexcept ValidationError as e_next:\nraise exit_with_error(f\"Talk still invalid. {e_next}\") from e_next\nstderr_console.print(\"New talk created. \ud83e\ude85\")\n_print_talk(result, show_json, plain)\n</code></pre>","tags":["robustness","option"]},{"location":"interactivity/#remark","title":"Remark","text":"<p>Typer also provides CLI option with Prompt</p> <p>This allows for less fine-grained control. (It doesn't take into account the <code>--interactive/--no-interactive</code> flag.)</p>","tags":["robustness","option"]},{"location":"interactivity/#more-info","title":"More Info","text":"<ul> <li>CLI Guidelines / Interactivity</li> <li>Rich: Prompt docs</li> </ul>","tags":["robustness","option"]},{"location":"option-with-aliases/","title":"Option with aliases","text":"","tags":["option","naming"]},{"location":"option-with-aliases/#overview","title":"Overview","text":"<p>You can provide multiple aliases for an option. This is helpful when multiple expressions are common for the same concept.</p>","tags":["option","naming"]},{"location":"option-with-aliases/#simple-option-with-multiple-aliases","title":"Simple Option with Multiple Aliases","text":"<p>An option that accepts both <code>--directory</code> and <code>--dir</code>:</p> <pre><code>@app.command()\ndef create(\ndirectory: Optional[Path] = typer.Option(\nNone, \"--directory\", \"--dir\", help=\"The directory of the page.\"\n),\n):\n</code></pre>","tags":["option","naming"]},{"location":"option-with-aliases/#option-with-full-length-and-short-name","title":"Option with Full-Length and Short Name","text":"<p>An option that accepts both <code>--all</code> and <code>-a</code>:</p> <pre><code>@app.command()\ndef ls(\nall: bool = typer.Option(False, \"--all\", \"-a\", help=\"Show all items.\"),\n):\n</code></pre> <p>CLIG's recommendation regarding short names:</p> <p>Only use one-letter flags for commonly used flags, particularly at the top-level when using subcommands. That way you don\u2019t \u201cpollute\u201d your namespace of short flags, forcing you to use convoluted letters and cases for flags you add in the future.</p> <p>CLIG / Arguments and Flags</p>","tags":["option","naming"]},{"location":"option-with-aliases/#bool-option-with-multiple-aliases","title":"<code>bool</code> Option with Multiple Aliases","text":"<p>By default, a <code>bool</code> option defines one name for the <code>True</code> value and one for the <code>False</code> value. see Bool Option</p> <p>You can also define a <code>bool</code> option with 2 names both for the <code>True</code> and the <code>False</code> value:</p> <pre><code>@app.command()\ndef create(\ninteractive_option: bool = typer.Option(\nTrue,\n\"--interactive/--no-interactive\",\n\"--input/--no-input\",\nhelp=\"Switch whether interactive prompts are shown. Use `--no-input` when you call this command from scripts.\",\n)\n):\n</code></pre>","tags":["option","naming"]},{"location":"option-with-aliases/#more-info","title":"More Info","text":"<ul> <li>Typer Docs / CLI Option Name</li> <li>Typer Docs / Boolean CLI Options</li> <li>CLIG / Arguments and Flags</li> </ul>","tags":["option","naming"]},{"location":"pytest-fixture-for-test-objects/","title":"Use pytest Fixtures for Creating Test Objects","text":"","tags":["testing"]},{"location":"pytest-fixture-for-test-objects/#overview","title":"Overview","text":"<p>If a test needs one or more objects, provide them via pytest fixtures.</p> <p>Do not run multiple <code>invoke</code>s of <code>typer.testing.CliRunner</code> in one test.</p>","tags":["testing"]},{"location":"pytest-fixture-for-test-objects/#example","title":"Example","text":"<p>Fixture:</p> <pre><code>@pytest.fixture()\ndef create_basic_talk():\nreturn talk_crud().create({\"short_name\": \"error-messages\"})\n</code></pre> <p>Test function:</p> <pre><code>def test_existing_by_id(create_basic_talk):\nresult = runner.invoke(app, [\"talk\", \"view\", str(create_basic_talk.id_)])\nassert result.exit_code == 0\nassert result.stdout\n</code></pre> <p>This provides a clear separation between the different phases of the test:</p> <ul> <li>arrange</li> <li>act</li> <li>assert</li> </ul>","tags":["testing"]},{"location":"pytest-fixture-for-test-objects/#pitfall","title":"Pitfall","text":"<p>Another possibility would be to invoke the <code>create</code> command in the test before invoking the \"command under test\" <code>view</code>.</p> <pre><code>def test_existing_by_id(create_basic_talk):\nrunner.invoke(app, [\"talk\", \"create\", \"--short-name\", \"some-name\"]\nresult = runner.invoke(app, [\"talk\", \"view\", str(create_basic_talk.id_)])\nassert result.exit_code == 0\nassert result.stdout\n</code></pre> <p>Drawback: If the <code>create</code> command fails, the <code>invoke</code> is still successful and proceeds to the next step.</p> <p>=&gt;</p> <p>The invoking of the <code>view</code> command will fail, which is misleading. (The <code>create</code> command has an error, but the test fails in the <code>view</code> step.)</p>","tags":["testing"]},{"location":"pytest-fixture-for-test-objects/#more-info","title":"More Info","text":"<ul> <li>About pytest Fixtures</li> <li>AAA Arrange-Act-Assert Pattern</li> </ul>","tags":["testing"]},{"location":"raising-an-error/","title":"Raising an Error in Typer","text":"","tags":["error-handling","consistency"]},{"location":"raising-an-error/#overview","title":"Overview","text":"<p>If an error happens, ensure that:</p> <ul> <li> The command returns a non-zero exit code.</li> <li> Nothing is printed to <code>stdout</code>.</li> <li> Some error message is printed to <code>stderr</code>.</li> </ul> <p>The exit code of the last command is stored in the shell variable <code>$?</code>.</p> <p>You can check that with:</p> <pre><code>echo $?\n</code></pre>","tags":["error-handling","consistency"]},{"location":"raising-an-error/#recommended-practice-helper-function","title":"Recommended Practice: Helper Function","text":"<p>Use a helper function for raising errors.</p> <p>Benefits:</p> <ul> <li>ensuring that a non-zero exit code is returned</li> <li>ensuring that an error message is shown</li> <li>consistent error messages</li> </ul> <p>Example:</p> <pre><code>def exit_with_error(error_msg: str, code: int = 1) -&gt; typer.Exit:\nstderr_console = Console(stderr=True, style=\"bold red\")\nstderr_console.print(error_msg)\nreturn typer.Exit(code=code)\n</code></pre> <p>In the caller:</p> <pre><code>if some_error_happened:\nraise exit_with_error(str(e)) from e\n</code></pre>","tags":["error-handling","consistency"]},{"location":"raising-an-error/#pitfalls","title":"Pitfalls","text":"","tags":["error-handling","consistency"]},{"location":"raising-an-error/#raising-typerexit-without-providing-a-code","title":"Raising typer.Exit() without Providing a Code","text":"<pre><code>raise typer.Exit()\n</code></pre> <p>The command will return with exit code 0.</p>","tags":["error-handling","consistency"]},{"location":"raising-an-error/#testing","title":"Testing","text":"<p>Example test for an error case:</p> <pre><code>def test_view_not_existing_talk():\nresult = runner.invoke(app, [\"talk\", \"view\", \"42\"])\nassert result.exit_code == 1\nassert not result.stdout\nassert result.stderr == \"Talk with ID 42 not found.\\n\"\n</code></pre>","tags":["error-handling","consistency"]},{"location":"raising-an-error/#more-info","title":"More Info","text":"<ul> <li><code>typer.Exit</code> docs</li> <li>CLIG Guidelines / The Basics</li> </ul>","tags":["error-handling","consistency"]},{"location":"re-using-options/","title":"Re-using Typer Options","text":"","tags":["consistency","option","naming"]},{"location":"re-using-options/#overview","title":"Overview","text":"<p>Options used for multiple commands can be defined at a common place. This makes the option name and docs consistent.</p>","tags":["consistency","option","naming"]},{"location":"re-using-options/#example","title":"Example","text":"<p>Define the option:</p> <pre><code>short_name_option: str = typer.Option(\nNone,\nhelp=\"The short name of the talk.\",\n)\n</code></pre> <p>Reference the option in the command argument:</p> <pre><code>@app.command()\ndef create(\nshort_name: str = short_name_option,\n</code></pre>","tags":["consistency","option","naming"]},{"location":"re-using-options/#more-info","title":"More Info","text":"<ul> <li>CLI Options with Help</li> <li>CLIG / Arguments and Flags</li> </ul>","tags":["consistency","option","naming"]},{"location":"stdout-vs-stderr/","title":"Stdout vs stderr","text":"","tags":["interface"]},{"location":"stdout-vs-stderr/#overview","title":"Overview","text":"<p>When code prints things, it actually writes to one of two virtual files: \"standard output\" or \"standard error\".</p> <ul> <li>For a human user, there's usually no difference: Both <code>stdout</code> and <code>stderr</code> are visible on the terminal.</li> <li>For machines, there's a difference: A script consuming the output of your script \"sees\" only <code>stdout</code>.</li> </ul> <p>Distinguishing between <code>stdout</code> and <code>stderr</code>, is one of the Basics recommended by the CLIG</p> <p>TLDR</p> <ul> <li>Send output that can be piped and consumed by a next script to <code>stdout</code>.</li> <li>Send everything else, especially errors and log messages to <code>stderr</code>.</li> </ul> <p>For more explanation, on <code>stdout</code> and <code>stderr</code>, see also the Typer Docs</p>","tags":["interface"]},{"location":"stdout-vs-stderr/#printing-to-stdout-vs-stderr-with-rich","title":"Printing to <code>stdout</code> vs <code>stderr</code> with Rich","text":"<p>In Rich, you use a <code>rich.console.Console</code> object for printing.</p> <ul> <li>By default, it prints to <code>stdout</code>.</li> <li>You can initialize the <code>Console</code> with <code>stderr=True</code>, so that it prints to <code>stderr</code>.</li> </ul> <p>After creating a talk, print:</p> <ul> <li>the talk ID to <code>stdout</code></li> <li>a logging message to <code>stderr</code></li> </ul> <pre><code>from rich.console import Console\nstdout_console = Console()\nstderr_console = Console(stderr=True)\nstdout_console.print(talk.talk_id)\nstderr_console.print(\"New talk created. \ud83e\ude85\")\n</code></pre>","tags":["interface"]},{"location":"stdout-vs-stderr/#testing","title":"Testing","text":"<p>For tests with <code>typer.testing.CliRunner</code>, it's recommended to verify the content of <code>stdout</code> and <code>stdin</code> separately.</p> <p>In order to do that, you need to initialize the <code>typer.testing.CliRunner</code> instance with <code>mix_stderr=False</code>.</p> <pre><code>runner = CliRunner(mix_stderr=False)\n</code></pre>","tags":["interface"]},{"location":"stdout-vs-stderr/#iteration-vs-keeping-the-interface-stable","title":"Iteration vs Keeping the Interface Stable","text":"<p>Changing output for humans is usually OK. The only way to make an interface easy to use is to iterate on it, and if the output is considered an interface, then you can\u2019t iterate on it. Encourage your users to use --plain or --json in scripts to keep output stable (see Output).</p> <p>CLIG Guidelines / Future-proofing</p>","tags":["interface"]},{"location":"stdout-vs-stderr/#more-info","title":"More Info","text":"<ul> <li>Typer Docs / Printing and Colors / \"Standard Output\" and \"Standard Error\"</li> <li>CLIG Guidelines / Basics</li> <li>CLIG Guidelines / Future-proofing</li> </ul>","tags":["interface"]},{"location":"tags/","title":"Tags","text":"<p>Following is a list of tags:</p>"},{"location":"tags/#command","title":"command","text":"<ul> <li>Command alias</li> <li>Command custom name</li> </ul>"},{"location":"tags/#configuration","title":"configuration","text":"<ul> <li>Configure the Path of a SQLite Database</li> </ul>"},{"location":"tags/#consistency","title":"consistency","text":"<ul> <li>Raising an Error in Typer</li> <li>Re-using Typer Options</li> </ul>"},{"location":"tags/#error-handling","title":"error-handling","text":"<ul> <li>Raising an Error in Typer</li> </ul>"},{"location":"tags/#interface","title":"interface","text":"<ul> <li>Stdout vs stderr</li> </ul>"},{"location":"tags/#naming","title":"naming","text":"<ul> <li>Command alias</li> <li>Command custom name</li> <li>Option with aliases</li> <li>Re-using Typer Options</li> </ul>"},{"location":"tags/#option","title":"option","text":"<ul> <li>Bool option</li> <li>Interactive Input</li> <li>Option with aliases</li> <li>Re-using Typer Options</li> </ul>"},{"location":"tags/#robustness","title":"robustness","text":"<ul> <li>Show Help for Missing Subcommand</li> <li>Interactive Input</li> </ul>"},{"location":"tags/#testing","title":"testing","text":"<ul> <li>Use pytest Fixtures for Creating Test Objects</li> <li>Using <code>typer.testing.CliRunner</code></li> </ul>"},{"location":"typer-testing-clirunner/","title":"Using `typer.testing.CliRunner`","text":"","tags":["testing"]},{"location":"typer-testing-clirunner/#overview","title":"Overview","text":"<p><code>typer.testing.CliRunner</code> is a great tool for testing <code>typer</code> applications.</p> <p>Checklist:</p> <ul> <li> Initialize with <code>mix_stderr=False</code></li> <li> Ensure that each argument of <code>invoke</code> is a string.</li> <li> When asserting the value of <code>stdout</code> or <code>stderr</code>, add a trailing line break.</li> </ul>","tags":["testing"]},{"location":"typer-testing-clirunner/#initialization","title":"Initialization","text":"<pre><code>runner = CliRunner(mix_stderr=False)\n</code></pre> <p>By default, <code>CliRunner</code> is created with <code>mix_stderr=True</code>. This means, that the content of <code>stdout</code> and <code>stderr</code> will both appear in <code>result.stdout</code>.</p> <p>Recommended practice: Verify separately the content of <code>stdout</code> and <code>stderr</code>. =&gt; Create the <code>CliRunner</code> instance with <code>mix_stderr=False</code></p> <p>Verifying the content of <code>stdout</code> and <code>stderr</code> separately after invoking a command:</p> <pre><code>from pycon_catalogue.cli.cli import app\nrunner = CliRunner(mix_stderr=False)\ndef test_success(cmd_parts):\nresult = runner.invoke(app, \"create\", \"--name\", \"something\")\nassert result.exit_code == 0\nassert result.stdout\n# stderr\nassert \"New talk created. \ud83e\ude85\" in result.stderr\n</code></pre> <p>Typer docs</p>","tags":["testing"]},{"location":"typer-testing-clirunner/#invoke-use-only-string-arguments","title":"Invoke: Use only string Arguments","text":"<p>Example:</p> <pre><code>def test_not_existing():\nresult = runner.invoke(app, [\"talk\", \"view\", \"42\"])\n</code></pre> <p>Pitfall:</p> <pre><code>def test_not_existing():\nresult = runner.invoke(app, [\"talk\", \"view\", 42])\n</code></pre> <p>This will lead to an error during invoking the command:</p> <p> <p>This is especially easy to oversee when testing error scenarios.</p>","tags":["testing"]},{"location":"typer-testing-clirunner/#asserting-stdout-and-stderr-add-a-trailing-line-break","title":"Asserting <code>stdout</code> and <code>stderr</code>: Add a Trailing Line Break","text":"<pre><code>assert result.stderr == \"Talk with ID 42 not found.\\n\"\n</code></pre>","tags":["testing"]},{"location":"typer-testing-clirunner/#more-info","title":"More Info","text":"<ul> <li>Typer Testing docs</li> </ul>","tags":["testing"]},{"location":"tags/","title":"Tags","text":"<p>Following is a list of tags:</p>"},{"location":"tags/#command","title":"command","text":"<ul> <li>Command alias</li> <li>Command custom name</li> </ul>"},{"location":"tags/#configuration","title":"configuration","text":"<ul> <li>Configure the Path of a SQLite Database</li> </ul>"},{"location":"tags/#consistency","title":"consistency","text":"<ul> <li>Raising an Error in Typer</li> <li>Re-using Typer Options</li> </ul>"},{"location":"tags/#error-handling","title":"error-handling","text":"<ul> <li>Raising an Error in Typer</li> </ul>"},{"location":"tags/#interface","title":"interface","text":"<ul> <li>Stdout vs stderr</li> </ul>"},{"location":"tags/#naming","title":"naming","text":"<ul> <li>Command alias</li> <li>Command custom name</li> <li>Option with aliases</li> <li>Re-using Typer Options</li> </ul>"},{"location":"tags/#option","title":"option","text":"<ul> <li>Bool option</li> <li>Interactive Input</li> <li>Option with aliases</li> <li>Re-using Typer Options</li> </ul>"},{"location":"tags/#robustness","title":"robustness","text":"<ul> <li>Show Help for Missing Subcommand</li> <li>Interactive Input</li> </ul>"},{"location":"tags/#testing","title":"testing","text":"<ul> <li>Use pytest Fixtures for Creating Test Objects</li> <li>Using <code>typer.testing.CliRunner</code></li> </ul>"}]}