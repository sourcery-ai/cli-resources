{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Sourcery CLI Resources","text":"<p>Code examples &amp; design patterns for Python CLI applications.</p>"},{"location":"#libraries-used","title":"Libraries Used","text":"<ul> <li>typer</li> <li>Pydantic</li> <li>sqlite-utils</li> <li>Rich</li> </ul>"},{"location":"db-path-config/","title":"Configure the Path of a SQLite Database","text":"","tags":["configuration"]},{"location":"db-path-config/#overview","title":"Overview","text":"<p>We want to use different databases in the different environments:</p> <ul> <li>development</li> <li>tests</li> <li>production / live</li> </ul> <p>We use <code>pydantic.Settings</code> and an environment variable to make the path configurable.</p> <ul> <li>For development: set the environment variable.</li> <li>For tests: Use a pytest fixture with <code>tmpdir</code> to define a custom path.</li> </ul>","tags":["configuration"]},{"location":"db-path-config/#config","title":"Config","text":"<p>In a <code>config.py</code>:</p> <pre><code>from pathlib import Path\nfrom pydantic import BaseSettings, Field\nfrom sqlite_utils import Database\nfrom pycon_catalogue.initialize import init_db\nclass Settings(BaseSettings):\ndb_path: Path = Field(\nPath.home() / \"pycon-catalogue.db\", env=\"APP_NAME_DB_PATH\"\n)\ndef db(self) -&gt; Database:\nreturn Database(self.db_path)\nsettings: Settings = Settings()\n</code></pre> <p>Instead of <code>Path.home()</code>, you can also use a more sophisticated default value:</p> <ul> <li><code>typer.get_app_dir()</code></li> <li>platformdirs library</li> </ul>","tags":["configuration"]},{"location":"db-path-config/#setting-a-development-database","title":"Setting a Development Database","text":"<pre><code>export APP_NAME_DB_PATH=$HOME/dev-app-name.db\n</code></pre>","tags":["configuration"]},{"location":"db-path-config/#using-a-temporary-database-for-tests","title":"Using a Temporary Database for Tests","text":"<p>Use a db in <code>tmpdir</code>.</p> <pre><code>from pathlib import Path\nimport pytest\nfrom app_name import config\n@pytest.fixture(autouse=True)\ndef app_db_path(tmpdir):\nconfig.settings.db_path = Path(tmpdir / \"test-app-name.db\")\n</code></pre>","tags":["configuration"]},{"location":"db-path-config/#more-info","title":"More Info","text":"<ul> <li>Pydantic / Settings Management</li> <li><code>tmpdir</code></li> </ul>","tags":["configuration"]},{"location":"help-no-subcommand/","title":"Show Help for Missing Subcommand","text":"","tags":["robustness"]},{"location":"help-no-subcommand/#overview","title":"Overview","text":"<p>If no subcommand has been provided =&gt; Show the help of the command.</p> <p>(instead of raising an error)</p>","tags":["robustness"]},{"location":"help-no-subcommand/#example","title":"Example","text":"<pre><code>@app.callback(invoke_without_command=True)\ndef callback(ctx: typer.Context),\n) -&gt; None:\nif ctx.invoked_subcommand is None:\nConsole().print(ctx.get_help())\n</code></pre>","tags":["robustness"]},{"location":"help-no-subcommand/#more-info","title":"More Info","text":"<ul> <li>Typer Callback docs</li> <li>Typer Context docs</li> </ul>","tags":["robustness"]},{"location":"interactivity/","title":"Interactive Input","text":"","tags":["robustness"]},{"location":"interactivity/#overview","title":"Overview","text":"<ul> <li>Prompt for missing values instead of raising an error immediately.</li> <li>Do not prompt if <code>stdin</code> isn't an interactive terminal. \ud83d\udcbb</li> <li>Do not prompt if the <code>--no-input</code> or <code>--no-interactive</code> option has been provided</li> </ul>","tags":["robustness"]},{"location":"interactivity/#examples","title":"Examples","text":"","tags":["robustness"]},{"location":"interactivity/#basic-example","title":"Basic Example","text":"<p>Prompt for 1 option (<code>--description</code>) if missing.</p> <pre><code>import sys\nimport typer\nfrom rich.prompt import Prompt\n@app.command()\ndef create(\ndescription_option: str = typer.Option(\nNone,\n\"--description\",\nhelp=\"Ca. 1 sentence description.\",\n),\ninteractive_flag: bool = typer.Option(\nTrue,\n\"--interactive/--no-interactive\",\n\"--input/--no-input\",\nhelp=\"Switch whether interactive prompts are shown. Use `--no-input` when you call this command from scripts.\",\n),\n):\ninteractive = sys.stdin.isatty() and interactive_flag\ndescription = description_option or interactive and Prompt.ask(\"Description\")\n</code></pre>","tags":["robustness"]},{"location":"interactivity/#more-complex-example","title":"More Complex Example","text":"<ul> <li>If no fields were provided at all via options =&gt; Prompt for all fields.</li> <li>If the object can't be created =&gt; Prompt for the fields that have raised a validation error.</li> </ul> <pre><code>@app.command()\ndef create(\nctx: typer.Context,\nshort_name: str = short_name_option,\nduration_total_seconds: int = duration_total_seconds_option,\nspeaker_name: str = speaker_name_option,\ntitle: str = title_option,\nyoutube_video_id: str = youtube_video_id_option,\ninteractive_flag: bool = INTERACTIVE_OPTION,\nplain: bool = FormatOptions.PLAIN,\nshow_json: bool = FormatOptions.JSON,\n):\n\"\"\"Create a new talk\"\"\"\ninteractive = sys.stdin.isatty() and interactive_flag\nstdout_console = Console()\nstderr_console = Console(stderr=True)\nprovided_further_fields = _get_field_values(ctx, interactive, stderr_console)\ntry:\nresult = talk_crud().create(provided_further_fields)\nexcept ValidationError as e:\nif not interactive or not Talk.all_simple_field_errors(e):\nraise exit_with_error(f\"Can't create a talk. {e}\") from e\nfor error_data in e.errors():\nfield_name = error_data[\"loc\"][0]\nmsg = error_data[\"msg\"]\nstderr_console.print(f\"Validation error. {field_name} {msg}\")\nprovided_further_fields[field_name] = Prompt.ask(field_name)\ntry:\nresult = talk_crud().create(provided_further_fields)\nexcept ValidationError as e_next:\nraise exit_with_error(f\"Talk still invalid. {e_next}\") from e_next\nstderr_console.print(\"New talk created. \ud83e\ude85\")\n_print_talk(result, show_json, plain)\n</code></pre>","tags":["robustness"]},{"location":"interactivity/#remark","title":"Remark","text":"<p>Typer also provides CLI option with Prompt</p> <p>This allows for less fine-grained control. (It doesn't take into account the <code>--interactive/--no-interactive</code> flag.)</p>","tags":["robustness"]},{"location":"interactivity/#more-info","title":"More Info","text":"<ul> <li>CLI Guidelines / Interactivity</li> <li>Rich: Prompt docs</li> </ul>","tags":["robustness"]},{"location":"pytest-fixture-for-test-objects/","title":"Use pytest Fixtures for Creating Test Objects","text":"","tags":["testing"]},{"location":"pytest-fixture-for-test-objects/#overview","title":"Overview","text":"<p>If a test needs one or more objects, provide them via pytest fixtures.</p> <p>Do not run multiple <code>invoke</code>s of <code>typer.testing.CliRunner</code> in one test.</p>","tags":["testing"]},{"location":"pytest-fixture-for-test-objects/#example","title":"Example","text":"<p>Fixture:</p> <pre><code>@pytest.fixture()\ndef create_basic_talk():\nreturn talk_crud().create({\"short_name\": \"error-messages\"})\n</code></pre> <p>Test function:</p> <pre><code>def test_existing_by_id(create_basic_talk):\nresult = runner.invoke(app, [\"talk\", \"view\", str(create_basic_talk.id_)])\nassert result.exit_code == 0\nassert result.stdout\n</code></pre> <p>This provides a clear separation between the different phases of the test:</p> <ul> <li>arrange</li> <li>act</li> <li>assert</li> </ul>","tags":["testing"]},{"location":"pytest-fixture-for-test-objects/#pitfall","title":"Pitfall","text":"<p>Another possibility would be to invoke the <code>create</code> command in the test before invoking the \"command under test\" <code>view</code>.</p> <pre><code>def test_existing_by_id(create_basic_talk):\nrunner.invoke(app, [\"talk\", \"create\", \"--short-name\", \"some-name\"]\nresult = runner.invoke(app, [\"talk\", \"view\", str(create_basic_talk.id_)])\nassert result.exit_code == 0\nassert result.stdout\n</code></pre> <p>Drawback: If the <code>create</code> command fails, the <code>invoke</code> is still successful and proceeds to the next step.</p> <p>=&gt;</p> <p>The invoking of the <code>view</code> command will fail, which is misleading. (The <code>create</code> command has an error, but the test fails in the <code>view</code> step.)</p>","tags":["testing"]},{"location":"pytest-fixture-for-test-objects/#more-info","title":"More Info","text":"<ul> <li>About pytest Fixtures</li> <li>AAA Arrange-Act-Assert Pattern</li> </ul>","tags":["testing"]},{"location":"raising-an-error/","title":"Raising an Error in Typer","text":"","tags":["error-handling","consistency"]},{"location":"raising-an-error/#overview","title":"Overview","text":"<p>If an error happens, ensure that:</p> <ul> <li> The command returns a non-zero exit code.</li> <li> Nothing is printed to <code>stdout</code>.</li> <li> Some error message is printed to <code>stderr</code>.</li> </ul> <p>The exit code of the last command is stored in the shell variable <code>$?</code>.</p> <p>You can check that with:</p> <pre><code>echo $?\n</code></pre>","tags":["error-handling","consistency"]},{"location":"raising-an-error/#recommended-practice-helper-function","title":"Recommended Practice: Helper Function","text":"<p>Use a helper function for raising errors.</p> <p>Benefits:</p> <ul> <li>ensuring that a non-zero exit code is returned</li> <li>ensuring that an error message is shown</li> <li>consistent error messages</li> </ul> <p>Example:</p> <pre><code>def exit_with_error(error_msg: str, code: int = 1) -&gt; typer.Exit:\nstderr_console = Console(stderr=True, style=\"bold red\")\nstderr_console.print(error_msg)\nreturn typer.Exit(code=code)\n</code></pre> <p>In the caller:</p> <pre><code>if some_error_happened:\nraise exit_with_error(str(e)) from e\n</code></pre>","tags":["error-handling","consistency"]},{"location":"raising-an-error/#pitfalls","title":"Pitfalls","text":"","tags":["error-handling","consistency"]},{"location":"raising-an-error/#raising-typerexit-without-providing-a-code","title":"Raising typer.Exit() without Providing a Code","text":"<pre><code>raise typer.Exit()\n</code></pre> <p>The command will return with exit code 0.</p>","tags":["error-handling","consistency"]},{"location":"raising-an-error/#testing","title":"Testing","text":"<p>Example test for an error case:</p> <pre><code>def test_view_not_existing_talk():\nresult = runner.invoke(app, [\"talk\", \"view\", \"42\"])\nassert result.exit_code == 1\nassert not result.stdout\nassert result.stderr == \"Talk with ID 42 not found.\\n\"\n</code></pre>","tags":["error-handling","consistency"]},{"location":"raising-an-error/#more-info","title":"More Info","text":"<ul> <li><code>typer.Exit</code> docs</li> <li>CLIG Guidelines / The Basics</li> </ul>","tags":["error-handling","consistency"]},{"location":"re-using-options/","title":"Re-using Typer Options","text":"","tags":["consistency"]},{"location":"re-using-options/#overview","title":"Overview","text":"<p>Options used for multiple commands can be defined at a common place. This makes the option name and docs consistent.</p>","tags":["consistency"]},{"location":"re-using-options/#example","title":"Example","text":"<p>Define the option:</p> <pre><code>short_name_option: str = typer.Option(\nNone,\nhelp=\"The short name of the talk.\",\n)\n</code></pre> <p>Reference the option in the command argument:</p> <pre><code>@app.command()\ndef create(\nshort_name: str = short_name_option,\n</code></pre>","tags":["consistency"]},{"location":"re-using-options/#more-info","title":"More Info","text":"<ul> <li>CLI Options with Help</li> <li>CLIG / Arguments and Flags</li> </ul>","tags":["consistency"]},{"location":"tags/","title":"Tags","text":"<p>Following is a list of tags:</p>"},{"location":"tags/#configuration","title":"configuration","text":"<ul> <li>Configure the Path of a SQLite Database</li> </ul>"},{"location":"tags/#consistency","title":"consistency","text":"<ul> <li>Raising an Error in Typer</li> <li>Re-using Typer Options</li> </ul>"},{"location":"tags/#error-handling","title":"error-handling","text":"<ul> <li>Raising an Error in Typer</li> </ul>"},{"location":"tags/#robustness","title":"robustness","text":"<ul> <li>Show Help for Missing Subcommand</li> <li>Interactive Input</li> </ul>"},{"location":"tags/#testing","title":"testing","text":"<ul> <li>Use pytest Fixtures for Creating Test Objects</li> <li>Using <code>typer.testing.CliRunner</code></li> </ul>"},{"location":"typer-testing-clirunner/","title":"Using `typer.testing.CliRunner`","text":"","tags":["testing"]},{"location":"typer-testing-clirunner/#overview","title":"Overview","text":"<p><code>typer.testing.CliRunner</code> is a great tool for testing <code>typer</code> applications.</p> <p>Checklist:</p> <ul> <li> Initialize with <code>mix_stderr=False</code></li> <li> Ensure that each argument of <code>invoke</code> is a string.</li> <li> When asserting the value of <code>stdout</code> or <code>stderr</code>, add a trailing line break.</li> </ul>","tags":["testing"]},{"location":"typer-testing-clirunner/#initialization","title":"Initialization","text":"<pre><code>runner = CliRunner(mix_stderr=False)\n</code></pre> <p>By default, <code>CliRunner</code> is created with <code>mix_stderr=True</code>. This means, that the content of <code>stdout</code> and <code>stderr</code> will both appear in <code>result.stdout</code>.</p> <p>Recommended practice: Verify separately the content of <code>stdout</code> and <code>stderr</code>. =&gt; Create the <code>CliRunner</code> instance with <code>mix_stderr=False</code></p> <p>Typer docs</p>","tags":["testing"]},{"location":"typer-testing-clirunner/#invoke-use-only-string-arguments","title":"Invoke: Use only string Arguments","text":"<p>Example:</p> <pre><code>def test_not_existing():\nresult = runner.invoke(app, [\"talk\", \"view\", \"42\"])\n</code></pre> <p>Pitfall:</p> <pre><code>def test_not_existing():\nresult = runner.invoke(app, [\"talk\", \"view\", 42])\n</code></pre> <p>This will lead to an error during invoking the command:</p> <p> <p>This is especially easy to oversee when testing error scenarios.</p>","tags":["testing"]},{"location":"typer-testing-clirunner/#asserting-stdout-and-stderr-add-a-trailing-line-break","title":"Asserting <code>stdout</code> and <code>stderr</code>: Add a Trailing Line Break","text":"<pre><code>assert result.stderr == \"Talk with ID 42 not found.\\n\"\n</code></pre>","tags":["testing"]},{"location":"typer-testing-clirunner/#more-info","title":"More Info","text":"<ul> <li>Typer Testing docs</li> </ul>","tags":["testing"]},{"location":"tags/","title":"Tags","text":"<p>Following is a list of tags:</p>"},{"location":"tags/#configuration","title":"configuration","text":"<ul> <li>Configure the Path of a SQLite Database</li> </ul>"},{"location":"tags/#consistency","title":"consistency","text":"<ul> <li>Raising an Error in Typer</li> <li>Re-using Typer Options</li> </ul>"},{"location":"tags/#error-handling","title":"error-handling","text":"<ul> <li>Raising an Error in Typer</li> </ul>"},{"location":"tags/#robustness","title":"robustness","text":"<ul> <li>Show Help for Missing Subcommand</li> <li>Interactive Input</li> </ul>"},{"location":"tags/#testing","title":"testing","text":"<ul> <li>Use pytest Fixtures for Creating Test Objects</li> <li>Using <code>typer.testing.CliRunner</code></li> </ul>"}]}